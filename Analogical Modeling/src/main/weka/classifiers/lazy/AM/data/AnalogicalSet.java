/*
 * **************************************************************************
 * Copyright 2012 Nathan Glenn                                              * 
 * Licensed under the Apache License, Version 2.0 (the "License");          *
 * you may not use this file except in compliance with the License.         *
 * You may obtain a copy of the License at                                  *
 *                                                                          *
 * http://www.apache.org/licenses/LICENSE-2.0                               *
 *                                                                          *
 * Unless required by applicable law or agreed to in writing, software      *
 * distributed under the License is distributed on an "AS IS" BASIS,        *
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *
 * See the License for the specific language governing permissions and      *
 * limitations under the License.                                           *
 ****************************************************************************/

package weka.classifiers.lazy.AM.data;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import weka.classifiers.lazy.AM.lattice.Subcontext;
import weka.classifiers.lazy.AM.lattice.Supracontext;
import weka.core.Instance;

/**
 * This class holds a list of the exemplars that influenced the predicted
 * outcome of a certain test item, along with the analogical effect of each.
 * 
 * @author Nate Glenn
 * 
 */
public class AnalogicalSet {

	/**
	 * Mapping of an exemplar to its analogical effect
	 */
	private Map<Instance, Double> exEffectMap = new HashMap<>();

	/**
	 * Mapping of exemplar to the number of pointers to it
	 */
	private Map<Instance, Integer> exPointerMap;

	private Map<Double, Integer> classPointerMap = new HashMap<>();

	private Map<Double, Double> classLikelihoodMap = new HashMap<>();

	private int totalPointers = 0;

	private Double classIndex = Double.NaN;
	private double classProbability = Double.NEGATIVE_INFINITY;

	/**
	 * The exemplar whose class is being predicted by this set
	 */
	private Instance classifiedExemplar;

	private static String newline = System.getProperty("line.separator");

	/**
	 * 
	 * @param supraList
	 *            Supracontext list generated by a Lattice
	 * @param testItem
	 *            Exemplar being classified
	 * @param linear
	 *            True if counting of pointers should be done linearly; false if
	 *            quadratically.
	 */
	public AnalogicalSet(List<Supracontext> supraList, Instance testItem,
			boolean linear) {

		this.classifiedExemplar = testItem;

		// find numbers of pointers to individual exemplars
		exPointerMap = getPointers(supraList, linear);

		// find the total number of pointers
		for (Instance e : exPointerMap.keySet())
			totalPointers += exPointerMap.get(e);

		// find the analogical effect of an exemplar by dividing its pointer
		// count by the total pointer count
		for (Instance e : exPointerMap.keySet())
			exEffectMap.put(e, exPointerMap.get(e)
					/ ((double) getTotalPointers()));

		// find the likelihood for a given outcome based on the pointers
		for (Instance e : exPointerMap.keySet()) {
			double classVal = e.classValue();
			if (classPointerMap.containsKey(classVal))
				classPointerMap.put(
						classVal,
						classPointerMap.get(classVal)
								+ exPointerMap.get(e));
			else
				classPointerMap.put(classVal, exPointerMap.get(e));
		}

		// set the likelihood of each possible class index to be its share of
		// the total pointers
		for (Double d : classPointerMap.keySet())
			classLikelihoodMap.put(d, classPointerMap.get(d)
					/ (double) totalPointers);
		// Set the class index to that with the highest likelihood
		Double temp;
		for (Double d : classLikelihoodMap.keySet()) {
			temp = classLikelihoodMap.get(d);
			if (temp > getClassProbability()) {
				classProbability = temp;
				classIndex = d;
			}
		}
	}

	/**
	 * See page 392 of the red book.
	 * 
	 * @param supraList
	 *            List of Supracontexts created by filling the supracontextual
	 *            lattice.
	 * @param linear
	 *            True if pointer counting should be done linearly; false if it
	 *            should be done quadratically
	 * @return A mapping of each exemplar to the number of pointers pointing to
	 *         it.
	 */
	private Map<Instance, Integer> getPointers(List<Supracontext> supraList,
			boolean linear) {
		Map<Instance, Integer> pointers = new HashMap<>();
		
		//number of pointers in a supracontext,
		//that is the number of exemplars in the whole thing
		int pointersInList = 0;
		int pointersToSupra = 0;
		//iterate all supracontext
		for (Supracontext supra : supraList) {
			if (!linear) {
				pointersInList = 0;
				//sum number of exemplars for each subcontext
				for (int index : supra.getData())
					pointersInList += Subcontext.getSubcontext(index).getExemplars().size();
			}
			//iterate subcontexts in supracontext
			for (int index : supra.getData()) {
				//number of supras containing this subcontext
				pointersToSupra = supra.getCount();
				//iterate exemplars in subcontext
				for (Instance e : Subcontext.getSubcontext(index).getExemplars()) {
					//pointers to exemplar = pointersToSupra * pointers in list
					// add together if already in the map
					if (pointers.get(e) != null)
						pointers.put(e, pointers.get(e)
								+ (linear ? 1 : pointersInList)
								* pointersToSupra);
					else
						pointers.put(e, (linear ? 1 : pointersInList)
								* pointersToSupra);
				}
			}
		}
		return pointers;
	}

	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder();

		sb.append("predicting:");
		sb.append(getClassifiedEx());
		sb.append(newline);

		sb.append("outcome: ");
		sb.append(classifiedExemplar.stringValue(classifiedExemplar.attribute(classifiedExemplar.classIndex())));
		sb.append(" (");
		sb.append(classProbability);
		sb.append(")");
		sb.append(newline);

		for (Entry<Instance, Double> e : exEffectMap.entrySet()) {
			sb.append(e.getKey());
			sb.append(": ");
			sb.append(e.getValue());
			sb.append(newline);
		}
		sb.append("Outcome likelihoods:" + newline);
		for (Double d : classLikelihoodMap.keySet()) {
			sb.append(classifiedExemplar.classValue() + ": ");
			sb.append(classLikelihoodMap.get(d) + newline);
		}

		sb.append("Exemplar pointers:" + newline);
		for (Double d : classPointerMap.keySet()) {
			sb.append(classifiedExemplar.classValue() + ": ");
			sb.append(classPointerMap.get(d) + newline);
		}

		return sb.toString();
	}

	/**
	 * 
	 * @return A mapping between exemplars and their analogical effect (decimal
	 *         percentage)
	 */
	public Map<Instance, Double> getExemplarEffectMap() {
		return exEffectMap;
	}

	/**
	 * 
	 * @return Mapping of exemplars in the analogical set to the number of
	 *         pointers to it
	 */
	public Map<Instance, Integer> getExemplarPointers() {
		return exPointerMap;
	}

	/**
	 * 
	 * @return A mapping between a possible class index and its likelihood
	 *         (decimal probability)
	 */
	public Map<Double, Double> getClassLikelihoodMap() {
		return classLikelihoodMap;
	}

	/**
	 * 
	 * @return The total number of pointers in this analogical set
	 */
	public int getTotalPointers() {
		return totalPointers;
	}

	/**
	 * 
	 * @return A mapping between a class value index the number of pointers
	 *         pointing to it
	 */
	public Map<Double, Integer> getClassPointers() {
		return classPointerMap;
	}

	/**
	 * 
	 * @return A mapping between the class value index and its selection
	 *         probability
	 */
	public Map<Double, Double> getClassLikelihood() {
		return classLikelihoodMap;
	}

	/**
	 * 
	 * @return The exemplar which was classified
	 */
	public Instance getClassifiedEx() {
		return classifiedExemplar;
	}

	/**
	 * 
	 * @return Probability of the predicted class
	 */
	public double getClassProbability() {
		return classProbability;
	}

	/**
	 * 
	 * @return Index of the predicted class attribute value
	 */
	public double getIndex() {
		return classIndex;
	}
}
