<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>AM - how the Analogical Modeling algorithm works</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body style="background-color: white">


<!-- INDEX BEGIN -->
<div name="index">
<p><a name="__index__"></a></p>

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<ul>

		<li><a href="#the_supracontextual_lattice">The supracontextual lattice</a></li>
		<li><a href="#subcontexts">Subcontexts</a></li>
		<li><a href="#filling_the_supracontextual_lattice">Filling the supracontextual lattice</a></li>
		<li><a href="#homogeneity_and_heterogeneity">Homogeneity and Heterogeneity</a></li>
		<li><a href="#the_analogical_set">The Analogical Set</a></li>
	</ul>

</ul>

<hr name="index" />
</div>
<!-- INDEX END -->

<p>
</p>
<h1><a name="name">NAME</a></h1>
<p>AM - how the Analogical Modeling algorithm works</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<p><em>Exemplar-based modeling</em> works as follows: there is a set of data
items, each assigned an outcome, and there is a test item.  The test
item is compared with the data items; the result of this comparison
tells what the possible outcomes of the test item are, along with
their likelihoods.</p>
<p>Exemplar-based modeling is often contrasted with <em>rule-based
modeling</em>.  Note that in rule-based modeling, there can be only one
possible outcome, unless the model is fudged by introducing
probability.  (Some types of exemplar-based modeling also give only
one possible outcome.)</p>
<p><em>Analogical Modeling</em> (AM) is one way to do the comparison and
determine the outcome.  Some of its salient features are as follows:</p>
<ul>
<li>
<p>Exemplars that seem less similar to the test item than those that seem
more similar can still have a magnified effect if there are many of
them.  This is known as the <em>gang effect</em>.</p>
</li>
<li>
<p>AM accounts for <em>leakage</em>.</p>
<p>For instance, it is possible for someone to accidentally say &quot;snew&quot;
instead of &quot;snowed&quot;, in analogy with &quot;know/knew&quot;, &quot;grow/grew&quot;,
&quot;throw/threw&quot;, &quot;blow/blew&quot;, etc.  (I've never done this myself, though
I know someone who has.)  In rule-based modeling, this could never
occur; in AM, this is predicted to occur, though with very low
frequency.</p>
</li>
</ul>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>First, the user must create a set of data items, with their outcomes,
and some test items.  All of these items are represented by <em>feature
vectors</em>.  These feature vectors are <em>not</em> created by the AM
algorithm; they could be generated by hand or script, it matters not
to AM.  All the feature vectors must be of the same length, call it
<em>n</em>.</p>
<p>
</p>
<h2><a name="the_supracontextual_lattice">The supracontextual lattice</a></h2>
<p>AM requires the construction of a <em>supracontextual lattice</em>.  It is
merely a complete distributive lattice of sets called
<em>supracontexts</em>, each one labeled with an integer in the range 0
to 2^<em>n</em>&nbsp;-&nbsp;1.  If <em>a</em> and <em>b</em> are labels of two supracontexts,
then <em>a</em> &amp; <em>b</em> = <em>b</em> (that's bitwise AND) iff the supracontext
labeled by <em>a</em> is a superset of the supracontext labeled by <em>b</em>.</p>
<p>The supracontextual lattice starts out with every element being the
empty set.  The AM algorithm adds <em>subcontexts</em> to them one at a
time.</p>
<p>
</p>
<h2><a name="subcontexts">Subcontexts</a></h2>
<p>Subcontexts are also sets, and they are also labeled with an integer
in the range 0 to 2^<em>n</em>&nbsp;-&nbsp;1.  The elements of the subcontexts are
data items.</p>
<dl>
<dt><strong><a name="example" class="item">Example</a></strong></dt>

<dd>
<p>Suppose that the test item has feature vector</p>
<p>('S', 'O', '0', 'S', 'R', '0', 'T', 'A')</p>
<p>and a data item has the feature vector</p>
<p>('P', 'Y', 'V', 'S', 'R', '0', 'T', 'a').</p>
<p>Compare the corresponding features, using a 1 for different and 0 for
same.  Then the binary number</p>
<p>0b11100001</p>
<p>is the label of the subcontext to which the data item belongs.</p>
</dd>
</dl>
<p>
</p>
<h2><a name="filling_the_supracontextual_lattice">Filling the supracontextual lattice</a></h2>
<p>The elements of the supracontexts are the subcontexts.  If a
subcontext has label <em>a</em>, then it will be an element of any
supracontext whose label <em>b</em> satisfies <em>b</em> &amp; <em>a</em> = <em>a</em>.</p>
<p>Thus, the subcontext labeled by 0b11100001 will belong to 16 different
supracontexts.  The labels of these supracontexts are found by
replacing the 0s by 1s in all possible ways; the original 1s are left
untouched.</p>
<p>
</p>
<h2><a name="homogeneity_and_heterogeneity">Homogeneity and Heterogeneity</a></h2>
<p>A supracontext is <em>heterogeneous</em> if the following two conditions
hold:</p>
<ol>
<li>
<p>The supracontext contains two or more subcontexts.</p>
</li>
<li>
<p>The data items contained in these subcontexts do not share a common
outcome.</p>
</li>
</ol>
<p>Otherwise, the supracontext is <em>homogeneous</em>.  Only homogeneous
supracontexts determine the possible outcomes.</p>
<p>
</p>
<h2><a name="the_analogical_set">The Analogical Set</a></h2>
<p>The <em>analogical set</em> is a list of all data items that appear in the
subcontexts in the homogeneous supracontexts.  With each data item is
associated a number which is one of the following:</p>
<dl>
<dt><strong><a name="number_of_occurrences" class="item">Number of <em>occurrences</em></a></strong></dt>

<dd>
<p>This is merely the number of supracontexts containing the subcontext
containing the data item.</p>
</dd>
<dt><strong><a name="number_of_pointers" class="item">Number of <em>pointers</em></a></strong></dt>

<dd>
<p>Assign to each supracontext a number representing the total number of
data items in the subcontexts it contains.  The number of pointers of
a particular data item is the sum of the numbers assigned to the
supracontexts containing the subcontext containing the data item.
(Number of occurrences can be thought of as assigning 1 to each
supracontext.)</p>
</dd>
</dl>
<p>Using pointers gives rise to <em>gang effects</em>: the ability of many data
items less similar to the test item but appearing in the same
subcontext to have more influence on the outcome than a few data items
more similar to the test item.</p>
<p>With the analogical set in hand, one can then describe the likelihood
of the various outcomes actually occurring by looking at the numbers
assigned to its data items.</p>

</body>

</html>
