<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>lattice - How to store and manipulate large lattices in C</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body style="background-color: white">


<!-- INDEX BEGIN -->
<div name="index">
<p><a name="__index__"></a></p>

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<li><a href="#boolean_algebras_and_lattices">BOOLEAN ALGEBRAS AND LATTICES</a></li>
	<ul>

		<li><a href="#notes_for_am">Notes for AM</a></li>
	</ul>

	<li><a href="#traversing_a_lattice">TRAVERSING A LATTICE</a></li>
	<li><a href="#lattices_as_products_of_smaller_lattices">LATTICES AS PRODUCTS OF SMALLER LATTICES</a></li>
</ul>

<hr name="index" />
</div>
<!-- INDEX END -->

<p>
</p>
<h1><a name="name">NAME</a></h1>
<p>lattice - How to store and manipulate large lattices in C</p>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>The Analogical Modeling (AM) algorithm requires constructing and
traversing large completely distributive lattices, also known as
Boolean algebras.  This document tells how we do it in <em class="file">Parallel.xs</em>.</p>
<p>A lot of what appears below could be used generally to store lattices;
that which applies specifically to <code>AM::Parallel</code> is so marked.</p>
<p>
</p>
<hr />
<h1><a name="boolean_algebras_and_lattices">BOOLEAN ALGEBRAS AND LATTICES</a></h1>
<p>If <em>n</em> is a positive integer, then the set of positive integers that
can be expressed in <em>n</em> or fewer bits, along with the operations &amp;
(bitwise AND) and | (bitwise OR), is an example of a <em>Boolean
algebra</em>.  It is also an example of a <em>lattice</em> which is <em>completely
distributive</em>.  Although all the lattices used in AM are in fact
Boolean algebras, it is customary to refer to them merely as lattices.</p>
<p>Any lattice can have a <em>partial order</em> imposed upon it; this is done
by defining <em>a</em> &lt;= <em>b</em> whenever <em>a</em> &amp; <em>b</em> = <em>b</em> (or
equivalently, <em>a</em> | <em>b</em> = <em>a</em>).  This partial order is symmetric,
transitive, and antireflexive (if <em>a</em> &lt;= <em>b</em> and <em>b</em> &lt;=
<em>a</em>, then <em>a</em> = <em>b</em>).  It's called a <em>partial</em> order because it is
often the case that neither <em>a</em> &lt;= <em>b</em> nor <em>b</em> &lt;= <em>a</em>.</p>
<p>A common way to draw lattices on paper is by putting elements that are
greater than other elements higher up on the paper, using line
segments to indicate the partial order.  Here's an example:</p>
<pre>
                000
                /|\
               / | \
              /  |  \
             /   |   \
           001  010  100
           | \  / \  / |
           |  \/   \/  |
           |  /\   /\  |
           | /  \ /  \ |
           011  101  110
             \   |   /
              \  |  /
               \ | /
                \|/
                111</pre>
<p>If you can get from one element to another by only going down along
the line segments, then the first element is greater than the second.</p>
<p>
</p>
<h2><a name="notes_for_am">Notes for AM</a></h2>
<ul>
<li>
<p>The elements of the lattice created by AM are sets.  The partial order
is defined as follows: <em>A</em> &lt;= <em>B</em> if <em>B</em> is a subset of <em>A</em>.
If you draw the lattice, the smaller sets are at the top.  This
lattice is known as the <em>supracontextual lattice</em>; its elements are
called <em>supracontexts</em>.</p>
</li>
<li>
<p>The value of <em>n</em>, and thus the size of the lattice, is determined by
the length of the <em>feature vector</em> of the test item (see <em class="file">AM.pod</em>
for more explanation).  There is a set corresponding to each <em>n</em>-bit
positive integer; furthermore, if set <em>A</em> corresponds to integer <em>a</em>
and set <em>B</em> corresponds to integer <em>b</em>, then <em>A</em> is a superset of
(or &quot;below&quot;) <em>B</em> if <em>a</em> &amp; <em>b</em> = <em>b</em>.</p>
</li>
<li>
<p>Many of the elements of the supracontextual lattice are equal as sets;
i.e., they have precisely the same members.  Thus, for those of you
who know a lot of math, it is important not to confuse the
supracontextual lattice with the Boolean algebra generated by the
power set of a set.  The supracontextual lattice <em>is</em> a Boolean
algebra of sets; where these sets come from is explained in <em class="file">AM.pod</em>.</p>
<p>To store the supracontextual lattice, it is enough to create an array
<code>lattice[]</code> of length 2^<em>n</em>, where <code>lattice[</code><em>a</em><code>]</code> contains a
pointer to a structure containing information about the elements of
the set corresponding to <em>a</em>.</p>
<p>Of course, the size of <code>lattice[]</code> grows exponentially with <em>n</em>; to
overcome that, see the section on <a href="#lattices_as_products_of_smaller_lattices">lattices as products of smaller lattices</a>.</p>
</li>
<li>
<p>The supracontextual lattice is built up by adding elements to these
sets one at a time.  When a new element is added to a set, it is a
simple thing to <code>memcpy</code> (actually, we use Perl's safe equivalent,
<code>Copy</code>) the original set to a new location, append the new element,
and change the pointer.  We only have to do this once; <em class="file">Parallel.xs</em>
keeps track of the creation of new sets, so sometimes all that is
necessary is the changing of a pointer.</p>
</li>
</ul>
<p>
</p>
<hr />
<h1><a name="traversing_a_lattice">TRAVERSING A LATTICE</a></h1>
<p>During the course of the AM algorithm, it is necessary to visit all
the supracontexts that lie &quot;below&quot; a given supracontext.  For
example, given that a supracontext is labeled</p>
<pre>
 1001011</pre>
<p>AM requires an iterator that produces</p>
<pre>
 1001111
 1011011
 1011111
 1101011
 1101111
 1111011
 1111111</pre>
<p>though the order in which these seven are produced is immaterial.</p>
<p><em class="file">Parallel.xs</em> does this by using a <em>Gray code</em>.  This is a method by
which only one bit flips (either from 0 to 1 or from 1 to 0) at each
step.  Deciding which bit to flip is done as follows:</p>
<ol>
<li>
<p>List the &quot;gaps&quot;; for</p>
<pre>
 1001011</pre>
<p>the gaps are</p>
<pre>
 0100000 = gaps[0]
 0010000 = gaps[1]
 0000100 = gaps[2]</pre>
<p>Each gap has exactly one 1 bit which lines up with a 0 in the original
number.</p>
</li>
<li>
<p>If there are <em>g</em> gaps, list the <em>g</em>-bit integers in reverse order:
in this case, 111, 110, ..., 001, 000.</p>
</li>
<li>
<p>Take each of these numbers in succession.  Determine where the
rightmost 1 is; its position determines which bit to flip:</p>
<pre>
 1001011
 1101011 = 1001011 ^               0100000 (rightmost 1 of 111 is bit 0, use gap[0])
 1111011 = 1101011 ^        0010000        (rightmost 1 of 110 is bit 1, use gap[1])
 1011011 = 1111011 ^               0100000 (rightmost 1 of 101 is bit 0, use gap[0])
 1011111 = 1011011 ^ 0000100               (rightmost 1 of 100 is bit 2, use gap[2])
 1111111 = 1011111 ^               0100000 (rightmost 1 of 011 is bit 0, use gap[0])
 1101111 = 1111111 ^        0010000        (rightmost 1 of 010 is bit 1, use gap[1])
 1001111 = 1101111 ^               0100000 (rightmost 1 of 001 is bit 0, use gap[0])</pre>
</li>
</ol>
<p>(As I write this, I see that finding the bit to flip is the same
problem of deciding which disk to move in the Towers of Hanoi
problem.)</p>
<p>
</p>
<hr />
<h1><a name="lattices_as_products_of_smaller_lattices">LATTICES AS PRODUCTS OF SMALLER LATTICES</a></h1>
<p>Consider the following lattice: the first number is the binary label,
and the other numbers represent the elements of the set with that
label:</p>
<pre>
 label  elements</pre>
<pre>
  0000
 
  0001  3
  0010
  0100  6
  1000
 
  0011  3
  0101  3 6
  0110  6
  1001  1 3
  1010  4
  1100  5 6
 
  0111  2 3 6
  1011  1 3 4 7
  1101  1 3 5 6
  1110  4 5 6
 
  1111  1 2 3 4 5 6 7</pre>
<p>(Verify that this is a lattice.)</p>
<p>This lattice can be stored as two smaller lattices:</p>
<pre>
 label  elements
 
    00  3
    01  2 3 6
    10  1 3 4 7
    11  1 2 3 4 5 6 7
 
 label  elements
 
    00  5 6
    01  1 3 5 6
    10  4 5 6
    11  1 2 3 4 5 6 7</pre>
<p>The set labeled by 1001 in the large lattice is precisely the
intersection of the sets labeled by 10 and 01 respectively in the
smaller lattices: {1, 3} is the intersection of {1, 3, 4, 7} and {1,
3, 5, 6}.</p>
<p><code>AM::Parallel</code> breaks the supracontextual lattice up into 4 smaller
lattices, resulting in a great savings of memory at the expense of
finding a lot of intersections.  But since the elements of the sets
are listed as increasing sequences of positive integers, finding the
intersection is actually quite straightforward.</p>
<p>To initialize, set <em>i</em> to point to the largest element of the first
set and <em>j</em> to point to the largest element of the second set.</p>
<ol>
<li>
<p>Move <em>i</em> to the left as long as it points to an integer larger than
that pointed to by <em>j</em>.</p>
</li>
<li>
<p>If <em>i</em> points to an integer less than the integer pointed to by <em>j</em>,
swap <em>i</em> and <em>j</em> so they point into the opposite sets; go to step 1.</p>
</li>
<li>
<p>If <em>i</em> and <em>j</em> point to equal values, put this equal value into the
intersection and move both <em>i</em> and <em>j</em> once to the left.</p>
</li>
<li>
<p>If <em>i</em> can't be moved, the algorithm ends.</p>
</li>
</ol>

</body>

</html>
